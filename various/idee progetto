rel rel rel rel rel
rel rel rel rel rel
rel rel rel rel rel
rel rel rel rel rel
rel rel rel rel rel

    salvare utenti principalmente:

°
salvare relazioni (nomi delle relazioni) in una metrice delle adiacenze --> grafo
                                    ˄
                                    |
forse possibile ottimizzazione spaziale usando liste che simulano array ma ci
        sono solo i blocchi effettivamente allocati, es 1 di seguito
                                    |
            bisogna vedere se le celle vuote in un array occupano
              spazio se non lo occupano --> array fa questa cosa

°
usare due hash fucntion per trovare indici della matrice (se uso liste problema
perchè non c'è indice bisogna aggiungere un array iniziale che contenga le liste
e l'hash function da indice dell'array, es 2 di seguito)

    salvare relazioni principalmente:

°
posso creare struttura dati salvando le relazioni che mi dice quali utenti hanno
quelle relazioni, ad esempio un BST (in ordine alfabetico) in cui i nodi sono la
testa di una lista che contiene i riferimenti agli utenti con la direzione della
relazione

°
BST in ordine alfabetico e ogni nodo punta ad una matrice delle adiacenze per un
grafo tra utenti che contiene come elementi booleani che dicono se la relazione
tra i due utenti c'è o meno       <-- forse è pesante come struttura dati


      esempi per ricordarmi le idee:

1)
rel rel void void rel
void rel void void rel
rel rel rel void void
rel void rel void rel void

void è il blocco vuoto, bisogna capire come concatenare questi blocchi vuoti che
non devono essere allocati.

2)
  array (gli indici sono gli utenti(nomi o ID)):

                      0-> (rel, utente)-> (rel, utente)
                      1-> (rel, utente)-> (rel, utente)
                      2-> (rel, utente)
                      3-> (rel, utente)-> (rel, utente)
                      .-> (rel, utente)
                      .
                      .

          utente indica l'indice dell'array iniziale


    Progetto:

alberi per relazioni                                           alberi per entità

alberi per relazioni:
  ogni nodo delle relazioni contiene un array con elementi che puntano alle
  entità: una entità (la ricevente), un contatore che dice quante sono le altre
  entità.
  °1 Per inserire relazione si fa ricerca binaria sulle entità se entità c'è si
     incrementa il contatore e se necessario si scambia con entità adiacenti, se
     non c'è si inserisce alla fine. Si deve aggiungere il puntatore alla
     relazione nell'albero delle entità.
  °2 Per eliminare relazione si fa ricerca binaria sulle entità se entità c'è si
     elimina e diminuisce contatore, se zero si fa free. Si deve eliminare il
     puntatore alla relazione dall'entità uscente.

alberi per entità:
  ogni nodo contiene nome entità e albero rosso nero di puntatori a relazioni
  che la coinvolgono
  °1 Per inserire si inserisce nell'albero
  °2 Per eliminare si elimina entità decrementando contatore tutte le relazioni
     a cui punta nell'albero, si fa free di tutti i puntatori
